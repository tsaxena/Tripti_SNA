"""
A set of functions to sample nodes of a graph.
 
Supported sampling methods:
- uniform_independent_node_sample
- random_walk
- metropolis_hastings_random_walk

Supported estimators:
- estimate_size
- estimate_mean

More details in:
M. Gjoka, M. Kurant, C. T. Butts and A. Markopoulou
"Walking in Facebook: A Case Study of Unbiased Sampling of OSNs"
INFOCOM 2010

Example:
>>> import networkx as nx
>>> G = nx.generators.wheel_graph(10)
>>> nx.random_walk(G, size=20)
[6, 7, 6, 7, 0, 3, 2, 3, 2, 0, 5, 0, 7, 6, 7, 6, 5, 6, 7, 6]
>>> nx.estimate_relative_size(G, nx.random_walk(G, size=1000), 'random_walk', [0,1,2,3,4])
0.50679999999999814

For more examples try 'nx.test_sampling()'



"""


#Author: Maciej Kurant
#
#Copyright (C) 2004-2010, NetworkX Developers
#Aric Hagberg <hagberg@lanl.gov>
#Dan Schult <dschult@colgate.edu>
#Pieter Swart <swart@lanl.gov>
#All rights reserved.
#
#Redistribution and use in source and binary forms, with or without
#modification, are permitted provided that the following conditions are
#met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#
#  * Redistributions in binary form must reproduce the above
#    copyright notice, this list of conditions and the following
#    disclaimer in the documentation and/or other materials provided
#    with the distribution.
#
#  * Neither the name of the NetworkX Developers nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
#
#THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
#"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
#LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
#A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
#OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
#SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
#LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
#DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
#THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
#OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.



import networkx as nx
import random


__author__ = """Maciej Kurant"""
__all__ = ['uniform_independent_node_sample', 'random_walk', 'metropolis_hastings_random_walk', 'estimate_relative_size', 'estimate_mean', 'test_sampling']



####################
def uniform_independent_node_sample(G, size=10):
    """
    uniform_independent_node_sample(G, size=10)
    
    Uniform independent sample (UIS) of nodes, with replacements
    
    Parameters
    ----------  
    G:            - networkx graph 
    size:         - the sample length (int)     
    """
    V = G.nodes()
    return [random.choice(V) for _ in xrange(int(size))]
        
                 
    


####################
def random_walk(G, start_node=None, size=10):    
    """
    random_walk(G, start_node=None, size=10):
    
    Returns a list of nodes sampled by the classic Random Walk (RW)
    
    Parameters
    ----------  
    G:            - networkx.Graph 
    start_node:   - starting node (if None, then chosen uniformly at random)
    size:         - the target sample length (int)
    """
    if type(G) != nx.Graph:
        raise nx.NetworkXException("G must be a simple undirected graph!") 
        
    if start_node==None:
        start_node = random.choice(G.nodes())
    
    v = start_node
    sample = [v]    
    while len(sample) < size:        
        v = random.choice(nx.neighbors(G, v))
        sample.append(v)
    return sample


####################  
def metropolis_hastings_random_walk(G, start_node=None, size=10):  
    """metropolis_hastings_random_walk(G, start_node=None, size=10)
    
    Returns a list of nodes sampled by the classic Metropolis Hastings Random Walk (MHRW)
    (with the uniform target node distribution) 
    
    Parameters
    ----------  
    G:            - networkx graph 
    start_node:   - starting node (if none, then chosen uniformly at random)
    size:         - the target sample length (int)
    """
    if type(G) != nx.Graph:
        raise nx.NetworkXException("G must be a simple undirected graph!") 
        
    if start_node==None:
        start_node = random.choice(G.nodes())
        
    sample = [start_node]        
    while len(sample) < size:
        v = sample[-1]
        neighbors = nx.neighbors(G, v)
        while len(sample) < size:
            c = random.choice(neighbors)    #c - candidate node
            if random.random() < float(G.degree(v))/G.degree(c):
                sample.append(c)   # move to c accapted
                break
            else:
                sample.append(v)   # move to c rejected - resample the current node (as if followed a self-loop)                               
    return sample    



###############################################################
#######################   ESTIMATORS  #########################
###############################################################


####################
def estimate_mean(G, values, sample, sample_type):
    """
    estimate_mean(G, values, sample, sample_type)
    
    Every node v has some value values[v] attached to it. Based on a sample of type 'sample_type', 
    we estimate and return the average value over all nodes. 

    Parameters
    ----------  
    G:                 - networkx.Graph 
    values:            - dictionary: nodes -> values
    sample:            - a node sample
    sample_type:   
        'uniform'      - for samples obtained in UIS or MHRW
        'random_walk'  - for samples obtained in random walks       
    """

    if type(G) != nx.Graph:
        raise nx.NetworkXException("G must be a simple undirected graph!")             
                
    if sample_type=='uniform':
        return sum(1.*values[v] for v in sample) /  len(sample)
    elif sample_type=='random_walk':   
        return sum(1.*values[v]/G.degree(v) for v in sample) / sum(1./G.degree(v) for v in sample)
    else:
        raise nx.NetworkXException("Parameter sample_type '%s' not understood. Use 'uniform', 'random_walk'." % sample_type) 


####################
def estimate_relative_size(G, sample, sample_type, label):
    """
    estimate_relative_size(G, sample, sample_type, label)

    Based on a sample of type 'sample_type', we estimate the relative number of nodes 
    of a given type, i.e., with G.node[v]['label']==label. 
    Parameter 'label' can also be a list/set of nodes of interest. 
    
    Parameters
    ----------  
    G:                 - networkx.Graph 
    sample:            - a node sample
    sample_type:   
        'uniform'      - for samples obtained in UNI or MHRW; a trivial case included for consistency and completeness only
        'random_walk'  - for samples obtained in random walks
    label:             - type of nodes we consider, i.e., those with G.node[v]['label']==label
                         if 'label' is a set or list, then it is interpreted as a set of nodes of interest
    
    """
    
    if type(G) != nx.Graph:
        raise nx.NetworkXException("G must be a simple undirected graph!") 

    if sample_type not in ('uniform', 'random_walk'):
        raise nx.NetworkXException("Parameter sample_type '%s' not understood. Use 'uniform', 'random_walk'." % sample_type) 
        

    values = {}
    if type(label) in (list,set):
        node_category_set = set(label)
        for v in sample:
            values[v] = 1 if v in  node_category_set else 0
    else:    
        for v in sample:
            values[v] = 1 if G.node[v].get('label',None)==label else 0
                
    return estimate_mean(G, values, sample, sample_type)



###############################################################
###################   EXAMPLE AND TEST  #######################
###############################################################


def test_sampling():
    
    def try_size_estimators(G,sample):
        print '%0.3f         %0.3f' % (estimate_relative_size(G, sample, sample_type='uniform', label='in'), estimate_relative_size(G, sample, sample_type='random_walk', label='in'))
        
    def try_mean_estimators(G,sample, values):
        print '%0.3f         %0.3f' % (estimate_mean(G, values, sample, sample_type='uniform'), estimate_mean(G, values, sample, sample_type='random_walk'))
    
        
    G = nx.generators.wheel_graph(10)
    print 
    print nx.info(G)

    
    print '\n**** Set node values to node numbers'
    values={}
    for v in G:
        values[v] = v
    
    print "\n**** Label nodes [0,2] as 'in'." 
    G.node[0]['label'] = 'in' 
    G.node[2]['label'] = 'in'         
    
    print """
**** Collect samples of N=10000 nodes:
UIS_sample  = uniform_independent_node_sample(G, size=N)
MHRW_sample = metropolis_hastings_random_walk(G, size=N)
RW_sample   = random_walk(G, size=N)"""
    N = 10000
    UIS_sample = uniform_independent_node_sample(G, size=N)  # 'uniform' is the correct estimator
    MHRW_sample = metropolis_hastings_random_walk(G, size=N) # 'uniform' is the correct estimator
    RW_sample  = random_walk(G, size=N)                      # 'random_walk' is the correct estimator
    
    
    print """
**** Estimate mean value:
          uniform   random_walk  <-- estimator
UIS_sample """,
    try_mean_estimators(G,UIS_sample, values)
    print 'MHRW_sample',
    try_mean_estimators(G,MHRW_sample, values)    
    print 'RW_sample  ', 
    try_mean_estimators(G,RW_sample, values)    
    print "            (the real mean is 4.5)"
    
    
    print """
**** Estimate the fraction of nodes labeled by "in":
          uniform   random_walk  <-- estimator
UIS_sample """,
    try_size_estimators(G,UIS_sample)
    print 'MHRW_sample',
    try_size_estimators(G,MHRW_sample)    
    print 'RW_sample  ', 
    try_size_estimators(G,RW_sample)
    print "            (the real size is 0.2)"

    
    print "\n**** Conclusions: "
    print "Set sample_type='uniform' for UIS_sample and MHRW_sample" 
    print "Set sample_type='random_walk' for RW_sample" 
    
